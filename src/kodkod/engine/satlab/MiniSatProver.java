/**
 * 
 */
package kodkod.engine.satlab;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import kodkod.util.collections.Arrays;
import kodkod.util.ints.IntVector;
import kodkod.util.ints.Ints;
import kodkod.util.ints.ArrayIntVector;

/**
 * Java wrapper for Niklas EŽn and Niklas Sšrensson MiniSAT solver 
 * with proof logging.
 * @author Emina Torlak
 */
final class MiniSatProver extends NativeSolver implements SATProver {
	private Clause proof;
	/**
	 * Constructs a new MiniSat prover wrapper.
	 */
	MiniSatProver() {
		super(make());
		proof = null;
	}

	/**
	 * Adapted from File.C (MiniSat proof decoder).  Reads a long
	 * from a data input stream containing a proof trace generated by MiniSat.
	 */
	private static long getLong(DataInputStream in) throws IOException {
		int  byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7;
		byte0 = in.readByte();
		if ((byte0 & 0x80)==0) {
			return byte0;
		} else {
			switch ((byte0 & 0x60) >> 5) {
			case 0:
				byte1 = in.readByte() & 0xFF;
				return ((byte0 & 0x1F) << 8) | byte1;
			case 1:
				byte1 = in.readByte() & 0xFF;
	            byte2 = in.readByte() & 0xFF;
	            return ((byte0 & 0x1F) << 16) | (byte1 << 8) | byte2;
			case 2:
	            byte1 = in.readByte() & 0xFF;
	            byte2 = in.readByte() & 0xFF;
	            byte3 = in.readByte() & 0xFF;
	            return ((byte0 & 0x1F) << 24) | (byte1 << 16) | (byte2 << 8) | byte3;
			default:
	            byte0 = in.readByte() & 0xFF;
	            byte1 = in.readByte() & 0xFF;
	            byte2 = in.readByte() & 0xFF;
	            byte3 = in.readByte() & 0xFF;
	            byte4 = in.readByte() & 0xFF;
	            byte5 = in.readByte() & 0xFF;
	            byte6 = in.readByte() & 0xFF;
	            byte7 = in.readByte() & 0xFF;
	            return ((long)((byte0 << 24) | (byte1 << 16) | (byte2 << 8) | byte3) << 32)
	                 |  (long)((byte4 << 24) | (byte5 << 16) | (byte6 << 8) | byte7);
			}
		}
	}
	
	/**
	 * Adapted from SolverTypes.h.  Decodes a literal index into the dimacs
	 * sign/variable format.
	 */
	private static int toLit(long idx) {
		return (idx & 1) == 1 ? -(int)(idx >> 1) - 1 : (int)(idx >> 1) + 1;
	}
	
	/**
	 * {@inheritDoc}
	 * @see kodkod.engine.satlab.SATProver#proof()
	 */
	public Clause proof() {
		if (!Boolean.FALSE.equals(status())) throw new IllegalStateException();
		if (proof==null) {
			try {
				final File temp = File.createTempFile("minisatprover",".prf");
				final int last = saveProof(peer(),temp.getAbsolutePath());
				free();
				
				final Clause[] clauses = new Clause[last+1];
				
				final DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream(temp)));				
				final IntVector literals = new ArrayIntVector();
				final List<SATProver.Clause> antecedents = new ArrayList<SATProver.Clause>();

				// adapted from Proof.c by Niklas Een and Niklas Sorensson
				for(int index = 0; index <= last; index++) {
					long tmp = getLong(in);
					if ((tmp & 1L) == 0) {
						// Root clause:	
						long idx = tmp >> 1;
						literals.append(toLit(idx));
						for(tmp = getLong(in); tmp != 0; tmp = getLong(in)) {
							idx += tmp;
							literals.append(toLit(idx));
						}
						literals.sort();
						clauses[index] = AbstractClause.root(index, Ints.asSet(literals.toArray()));
//						System.out.println("ROOT: " + clauses[index]);
						literals.clear();
					} else {
						// Derivation or Deletion:
						antecedents.add(clauses[(int)(index - (tmp >> 1))]);
						for(;;) {
							tmp = getLong(in);
							if (tmp == 0) break;
							tmp = (getLong(in));
							antecedents.add(clauses[(int)(index - tmp)]);
						}
						if (antecedents.size()==1) {
							index--; // (no new clause introduced -- deletion)
						} else { 
							Set<Clause> s = Arrays.asIdentitySet(Arrays.identitySort(antecedents.toArray(new Clause[antecedents.size()])));
							clauses[index] = AbstractClause.learned(index, s);
//							System.out.println("CHAIN: " + clauses[index]);
						}
						antecedents.clear();
					}
				}
				proof = clauses[last];
				in.close();
				temp.delete();
			} catch (IOException e) {
				throw new RuntimeException(e);
			}	
		}
		return proof;
	}
	
	/**
	 * {@inheritDoc}
	 * @see java.lang.Object#toString()
	 */
	public String toString() {
		return "MiniSatProver";
	}
	
	
	static {
		loadLibrary("minisatprover");
	}
	
	/**
	 * Returns a pointer to an instance of  MiniSAT.
	 * @return a pointer to an instance of minisat.
	 */
	private static native long make();
	
	/**
	 * Releases the resources associated with
	 * the given instance of minisat.  This method
	 * must be called when the object holding the
	 * given reference goes out of scope to avoid
	 * memory leaks.
	 * @effects releases the resources associated
	 * with the given instance of minisat
	 */
	native void free(long peer);
	
	/**
	 * Adds the given number of variables
	 * to the instance of minisat referenced
	 * by the first argument.
	 * @effects increases the vocabulary of the given instance
	 * by the specified number of variables
	 */
	native void addVariables(long peer, int numVariables);
	
	/**
	 * Adds the specified clause to the instance
	 * of minisat referenced by the first argument.
	 * @requires all i: lits[int] | some l: [1..numVariables(minisat) | 
	 *            i = l || i = -l
	 * @effects adds the given clause to the specified instance of minisat.
	 */
	native void addClause(long peer, int[] lits);
	
	/**
	 * Calls the solve method on the instance of 
	 * minisat referenced by the given long.
	 * @return true if sat, false otherwise
	 */
	native boolean solve(long peer);
	
	/**
	 * Returns the assignment for the given literal
	 * by the specified instance of minisat:  1 means
	 * the variable is TRUE, 0 that it's FALSE, and 
	 * -1 that it is UNDECIDED.
	 * @requires the last call to {@link #solve(long) solve(minisat)} returned SATISFIABLE
	 * @return the assignment for the given literal
	 */
	native boolean valueOf(long peer, int literal);

	/**
	 * Saves the proof of unsatisfiability generated by the last
	 * call to {@link #solve(long) solve(peer)} to the file with the given name,
	 * and returns the index of the last (conflict) clause in the proof. 
	 * @effects saves the proof of unsatisfiability generated by the last
	 * call to {@link #solve(long) solve(peer)} to the file with the given name.
	 * @return the index of the last (conflict) clause in the proof.
	 */
	native int saveProof(long peer, String file);

}
