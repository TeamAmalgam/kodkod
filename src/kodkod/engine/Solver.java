/*
 * Solver.java
 * Created on May 18, 2005
 */
package kodkod.engine;

import kodkod.ast.Formula;
import kodkod.ast.Relation;
import kodkod.core.bool.BooleanConstant;
import kodkod.core.fol2sat.AnnotatedBooleanValue;
import kodkod.core.fol2sat.Fol2SatTranslator;
import kodkod.core.sat2cnf.ContradictionException;
import kodkod.core.sat2cnf.Sat2CnfTranslator;
import kodkod.instance.Bounds;
import kodkod.instance.Instance;
import kodkod.util.IntSet;
import kodkod.util.Ints;

import org.sat4j.core.ASolverFactory;
import org.sat4j.minisat.SolverFactory;
import org.sat4j.specs.ISolver;
import org.sat4j.specs.TimeoutException;


/** 
 * Implementation of a computational engine for solving relational formulae.
 * A {@link kodkod.ast.Formula formula} is solved with respect to given 
 * {@link kodkod.instance.Bounds bounds}.
 * 
 * @specfield solverName: SATSolverName // name of the SAT solver used by this solver
 * @specfield timeout: int // timeout for the solver, in seconds
 *
 * @author Emina Torlak 
 */
public final class Solver {
	
	public static enum SATSolverName {
		Default,
		
		MiniLearning, MiniLearningPure,  MiniLearningNoRestarts, MiniLearningHeap, 
		MiniLearningEZSimp, MiniLearningHeapEZSimp, 
		MiniLearning2, MiniLearning2Heap, MiniLearning23, 
		MiniLearningCB, MiniLearningCBWL, MiniLearningCBWLPure,  MiniLearning2NewOrder, ActiveLearning, 
		
		MiniSAT, MiniSATNoRestarts,  MiniSATHeap, 
		MiniSAT2, MiniSAT2Heap,  MiniSAT23, MiniSAT23Heap, 
		Mini3SAT, Mini3SATb, 
		
		MinimalOPBMax, MiniOPBMax, 
		MinimalOPBMin, MiniOPBMin, 
		MiniCard, Relsat, Backjumping
	}
	
	
	private final ASolverFactory factory;
	private final SATSolverName solverName;
	private final int timeout;
	private int numPrimaryVars, numIntermediateVars, numClauses;
	
	/**
	 * Constructs a new Solver, that will use the SAT solver with the given 
	 * name and abort computation within the specified number of seconds, if necessary.
	 * If timeout is 0, then calls to solve will be allowed to run as long as necessary
	 * to obtain a solution
	 * @effects this.solverName' = solverName && this.timeout' = timeout
	 * @throws NullPointerException - solver = null
	 * @throws IllegalArgumentException - timeout < 0
	 */
	public Solver(final SATSolverName solverName, final int timeout) {
		if (solverName==null) throw new NullPointerException("solverName=null");
		if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
		this.timeout = timeout;
		this.factory = new SolverFactory();
		this.solverName = solverName;
		this.numPrimaryVars = this.numIntermediateVars = this.numClauses = -1;
	}
	
	/**
	 * Constructs a new Solver, that will use the SAT solver with the given 
	 * name and allow calls to this.solve to run as long as necessary
	 * to obtain a solution
	 * @effects this.solverName' = solverName && this.timeout' = 0
	 * @throws NullPointerException - solver = null
	 * @throws IllegalArgumentException - solver with the given name is not available
	 */
	public Solver(final SATSolverName solverName) {
		this(solverName, 0);
	}
	
	/**
	 * Constructs a new Solver that will use the default SAT solver with the 
	 * and abort computation within the specified number of seconds, if necessary.
	 * @effects  this.solverName' = Default && this.timeout' = timeout
	 * @throws IllegalArgumentException - timeout < 0
	 */
	public Solver(final int timeout) {
		this(SATSolverName.Default, timeout);
	}
	
	/**
	 * Constructs a new Solver, that will use the default SAT solver and allow calls to 
	 * this.solve to run as long as necessary to obtain a solution.
	 * @effects this.solverName' = Default && this.timeout' = 0
	 */
	public Solver() {
		this(SATSolverName.Default,0);
	}
	
	/**
	 * Returns the name of the SAT solver used by this Solver.
	 * @return this.solverName
	 */
	public SATSolverName solverName() { return solverName; }
	
	/**
	 * Returns the timeout of this Solver (in seconds).
	 * @return this.timeout
	 */
	public int timeout() { return timeout; }
	
	/**
	 * Returns the number of primary CNF variables generated while
	 * executing the last call to {@link #solve(Formula, Bounds)}.  
	 * If the solve method has not been called yet, returns -1.
	 * @return the number of primary CNF variables generated by
	 * the most recent call to {@link #solve(Formula, Bounds)}, or
	 * -1 if the method has not been called yet.
	 */
	public int numberOfPrimaryVariables() { return numPrimaryVars; }
	
	/**
	 * Returns the number of intermediate CNF variables generated while
	 * executing the last call to {@link #solve(Formula, Bounds)}.  
	 * If the solve method has not been called yet, returns -1.
	 * @return the number of intermediate CNF variables generated by
	 * the most recent call to {@link #solve(Formula, Bounds)}, or
	 * -1 if the method has not been called yet.
	 */
	public int numberOfIntermediateVariables() { return numIntermediateVars; }
	
	/**
	 * Returns the number of CNF clauses generated while
	 * executing the last call to {@link #solve(Formula, Bounds)}.  
	 * If the solve method has not been called yet, returns -1.
	 * @return the number of CNF clauses generated by
	 * the most recent call to {@link #solve(Formula, Bounds)}, or
	 * -1 if the method has not been called yet.
	 */
	public int numberOfClauses() { return numClauses; }
	
	/**
	 * Returns an int set view of the solution produced
	 * by the given solver to the given formula.
	 */
	private static IntSet getModel(ISolver solver, AnnotatedBooleanValue formula) {
		final int primaryVars = formula.numPrimaryVariables();
		final IntSet s = Ints.bestSet(1,primaryVars);
		final int model[] = solver.model();
		for(int i : model) {
			if (i > 0 && i <= primaryVars) s.add(i);
			else if (i > primaryVars || -i > primaryVars) break;
		}
		return s;
	}
	
	/**
	 * Converts the model returned by the solver into an instance using the annotations
	 * of the given formula.
	 * @return an Instance constructed from the information in the solver
	 * and the given formula
	 */
	private static Instance getInstance(AnnotatedBooleanValue formula, ISolver solver) {
		final IntSet model = getModel(solver, formula);
		final Bounds bounds = formula.bounds();
		final Instance instance = new Instance(bounds.universe());
		for(Relation r: bounds) {
			instance.add(r, formula.interpret(r, model));
		}
		return instance;
	}
	
	/**
	 * "Pads" the argument instance with the mappings that occur in bounds.lowerBound
	 * but not in the instance. 
	 * @requires instance.relations in bounds.relations
	 * @effects instance.relations' = bounds.relations' &&
	 *          instance.tuples' = bounds.lowerBound ++ instance.tuples
	 * @return instance
	 */
	private static Instance padInstance(Instance instance, Bounds bounds) {
		for(Relation r: bounds.relations()) {
			if (!instance.contains(r)) {
				instance.add(r, bounds.lowerBound(r));
			}
		}
		return instance;
	}
	
	/**
	 * Creates an instance from the given Bounds.  The instance
	 * is simply the mapping bounds.lowerBound.
	 * @return the instance corresponding to bounds.lowerBound
	 */
	private static Instance toInstance(Bounds bounds) {
		final Instance instance = new Instance(bounds.universe());
		for (Relation r : bounds) {
			instance.add(r, bounds.lowerBound(r));
		}
		return instance;
	}
	
	
	/**
	 * Attempts to satisfy the given formula with respect to the specified instance.
	 * If the operation is successful, the method returns a Model of the formula (in 
	 * conjunction with constraints implied by the instance).  If the formula and 
	 * the instance constraints cannot be satisfied, null is returned.
	 * 
	 * If the solver runs out of time, a TimeoutException is thrown.  
	 * 
	 * @return Model of the formula if it is satisfiable with respect to the instance; null otherwise.
	 * @throws NullPointerException - formula = null || bounds = null
	 * @throws IllegalArgumentException - the formula contains an unbound variable
	 * @throws IllegalArgumentException - the formula contains a relation not mapped by the given bounds object
	 * @throws TimeoutException - it takes more than this.timeout of seconds to solve the formula
	 */
	public Instance solve(Formula formula, Bounds bounds) throws kodkod.engine.TimeoutException {
		numPrimaryVars = numIntermediateVars = numClauses = 0;
		
		try {	
			final AnnotatedBooleanValue sat = Fol2SatTranslator.translate(formula, bounds);
			
//			System.out.println(formula);
//			System.out.println(sat);
			if (sat.value() == BooleanConstant.TRUE) {
				return toInstance(bounds);
			} else if (sat.value() == BooleanConstant.FALSE) { 
				return null;	
			} else {
				ISolver solver = (solverName==SATSolverName.Default ? 
						          factory.defaultSolver() : factory.createSolverByName(solverName.name()));
				if (timeout > 0) solver.setTimeout(timeout);
				Sat2CnfTranslator.translate(sat, solver);
				numPrimaryVars = sat.numPrimaryVariables();
				numIntermediateVars = solver.nVars() - numPrimaryVars;
				numClauses = solver.nConstraints();
				return (solver.isSatisfiable() ? padInstance(getInstance(sat, solver), bounds) : null);				
			}		
		} catch (TimeoutException to) {
			throw new kodkod.engine.TimeoutException(to.getMessage(), to);
		} catch (ContradictionException ce) {
			return null;
		}		
	}
	
	public String toString() {
		return "[SAT solver: " + solverName + ", timeout: " + timeout + "]";
	}

}
