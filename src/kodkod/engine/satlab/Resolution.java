/* 
 * Kodkod -- Copyright (c) 2005-2008, Emina Torlak
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package kodkod.engine.satlab;

import java.util.Iterator;
import java.util.List;
import java.util.Set;

import kodkod.util.ints.IntSet;


/**
 * <p>A proof of unsatisfiability generated by a given {@linkplain SATProver}.
 * Formally, a resolution trace is a sequence of inferences made by a  
 * prover that ends in a conflict (empty clause).  An element in a resolution
 * trace is called a clause.  There are two kinds of clauses in the trace: 
 * axioms and resolvents.  Axioms are the clauses given to the 
 * prover via the {@linkplain SATSolver#addClause(int[])} method, and resolvents are  
 * the clauses derived by the prover from axioms or previously learned resolvents through 
 * <a href="http://en.wikipedia.org/wiki/Resolution_%28logic%29">resolution</a>.</p>
 * 
 * <p>Clauses in a resolution trace are ordered as follows.  The first |<i>A</i>| elements
 * in the trace correspond to the axioms (clauses) with which the prover is initialized.  
 * An axiom <i>a1</i> precedes an axiom <i>a2</i> in the trace if and only if 
 * <i>a1</i> was added to the prover before <i>a2</i>.  (An axiom had been added to the 
 * prover, and appears in the trace, if and only if the corresponding call to {@linkplain SATSolver#addClause(int[])})
 * returned <tt>true</tt>.)  The remaining elements in the trace
 * are the resolvents that lead to a conflict.  A resolvent <i>r</i> succeeds
 * all of the resolvents needed for its derivation.  The last element in the trace is 
 * the conflict resolvent, and all resolvents in the trace are reachable from the conflict via the 
 * antecedent relation between clauses.  The axioms that are reachable from the conflict
 * form the <i>unsatisfiable core</i> of the trace. <p>
 * 
 * @specfield elts: Clause[]
 * @specfield conflict: elts[#elts-1]
 * @invariant all i,j: [0..#elts) | (i>=j and no elts[i].antecedents) => no elts[j].antecedents
 * @invariant all i: [0..#elts) | all ante: elts[i].antecedents[int] | elts.ante < i
 * @invariant all i: [0..#elts) | some elts[i].antecedents => elts[i] in conflict.*antecedents
 * @invariant no conflict.literals
 * 
 * @author Emina Torlak
 */
public interface Resolution extends Iterable<Resolution.Clause> {

	/**
	 * Returns the length of this trace.
	 * @return #this.elts
	 */
	public int size();
	
	/**
	 * Returns an iterator over the elements in this trace in proper sequence.
	 * <p><b>Note:</b>The clause objects returned by the iterator are not 
	 * required to be immutable.  In particular, the state of a clause object
	 * returned by <tt>next()</tt> is guaranteed to remain the same only until the
	 * subsequent call to <tt>next()</tt>.</p>
	 * @return an iterator over the elements in this trace in proper sequence.
	 */
	public Iterator<Clause> iterator();
	
	/**
	 * Returns an iterator over the elements in this trace between
	 * the given <tt>fromIndex</tt>, inclusive, and <tt>toIndex</tt>, exclusive. 
	 * If <tt>fromIndex</tt> <= <tt>toIndex</tt>, the elements are returned in 
	 * the ascending order of indices; otherwise, they are returned in the descending
	 * order of indices.
	 * <p><b>Note:</b>The clause objects returned by the iterator are not 
	 * required to be immutable.  In particular, the state of a clause object 
	 * returned by <tt>next()</tt> (as well as the state of any view object obtained
	 * through that clause's {@linkplain Clause#antecedents()} or {@linkplain Clause#literals()}
	 * methods) is guaranteed to remain the same only until the
	 * subsequent call to <tt>next()</tt>.</p>
	 * @requires fromIndex in [0..this.size()) and toIndex in [-1..this.size()]
	 * @return an iterator over the elements in this trace between
	 * the given <tt>fromIndex</tt>, inclusive, and <tt>toIndex</tt>, exclusive. 
	 * @throws IndexOutOfBoundsException - fromIndex !in [0..this.size()) or toIndex !in [-1..this.size()]
	 */
	public Iterator<Clause> iterator(int fromIndex, int toIndex);
		
	/**
	 * Returns a set view of the unsatisfiable core of this trace.  The returned set's
	 * iterator traverses the core in proper sequence (i.e. in the increasing order of 
	 * clause indices).
	 * <p><b>Note:</b>The clause objects returned by the set's iterator are not 
	 * required to be immutable.  In particular, the state of a clause object 
	 * returned by <tt>nex
	 * t()</tt> (as well as the state of any view object obtained
	 * through that clause's {@linkplain Clause#antecedents()} or {@linkplain Clause#literals()}
	 * methods) is guaranteed to remain the same only until the
	 * subsequent call to <tt>next()</tt>.</p>
	 * @return { axiom: Clause | no axiom.antecedents and axiom in this.conflict.^antecedents }
	 */
	public abstract Set<Clause> core();
		
	/**
	 * An element in a resolution trace.
	 * 
	 * @specfield trace: ResolutionTrace
	 * @specfield literals: set int
	 * @specfield antecedents: Clause[]
	 * @invariant 0 !in literals 
	 * @invariant no lit: literals | -lit in literals
	 * @invariant some antecedents => #antecedents > 1
	 * @invariant some antecedents => 
	 *  literals = { lit: antecedents[int].literals | 
	 *   no i: [0..#antecedents-1) | lit in antecedents[i].literals && -lit in antecedents[i+1].literals }
	 * 
	 * @author Emina Torlak
	 */
	public static interface Clause {
		
		/**
		 * Returns the index of this inference in this.trace.
		 * @return this.trace.elts.this
		 */
		public abstract int index();
				
		/**
		 * Returns an IntSet view of this.literals.
		 * @return an IntSet view of this.literals.
		 */
		public abstract IntSet literals();
		
		/**
		 * Returns the largest variable identifier occuring
		 * in this.literals.
		 * @return max(abs(this.literals))
		 */ 
		public abstract int maxVariable();
		
		/**
		 * Returns a List view of this.antecedents.
		 * @return a List view of this.antecedents.
		 */
		public abstract List<Clause> antecedents();
		
		/**
		 * Returns true if this is a learned (resolvent)
		 * clause.  Otherwise returns false.
		 * @return some this.antecedents
		 */
		public abstract boolean learned();
		
		/**
		 * Returns true if o is a clause  with the same state as this clause.
		 * @return o in Clause and o.trace.equals(this.trace) and 
		 * o.literals.equals(this.literals) and o.antecedents.equals(this.antecedents)
		 */
		public abstract boolean equals(Object o);
	}
	
}
